


---
Via zoom - temos gravação
---
# Full Open AI Whisper Transcript

Ok, são as 20h16, já a sessão está a ser gravada, com consentimento a sumo de todos os alunos, já que isto foi dito no modo que a sessão seria gravada, para que quem não venha e tenha decidido ver em diferido, em outro momento, possa fazê-lo. Esta sessão é a última sessão que nós temos sobre a área clássica de Search, de AI, o último tema que nós vamos tocar nesta área tão gira do AI clássico, a busca adversarial, mas antes de entrar nesse tema, como o tema de busca informada foi dado por primeira vez na semana passada, eu queria fazer um recap e até um pequeno exercício com vocês para garantir que vocês estão a entender o conteúdo. Portanto eu queria que algum voluntário me diga em termos narrativos, pode ser voluntário ou pode ser a dedo, isso depois vemos, narrativamente se eu estivesse em uma situação de quiz ou estivesse em um café com um colega e me perguntassem ok, eu percebi busca não informada e eu sei como funciona um DFS, sei como funciona um BFS, como explicariam numa narrativa coerente, lógica e para uma pessoa com alguma educação em AI, mas não igual que nós, o funcionamento do Dijkstra. Portanto seria para uma audiência semi-geral, como explicamos a narrativa do Dijkstra, voluntários? Estamos em um café com um colega, talvez um ano anterior, e a pessoa diz ok, eu percebo a lógica do DFS, do BFS, faz sentido, é sistematizar, sistematizar geometricamente como é que faz a ordem da visita dos nodes para encontrar um novo objetivo, as diferentes soluções que nós temos vindo implementar para lidar com loops e tudo mais também faz sentido, ok, tudo bem. Agora eu quero explicar de forma sucinta, narrativa, coerente e de alguma forma motivante o insight do algoritmo de Dijkstra, como fazemos isso em poucas palavras? Eu julgo que o Dijkstra vai sempre ou não com o menor peso, ou seja, eu sei que pela aquela ideia da ganância, tendo sempre, comparando os pesos que se tem através de uma, falta uma palavra, através dos dados de conhecimento como são dados, ou seja, falta uma palavra disso. Então, o que é que sugiro, eu sugiro que em uma situação destas, a primeira coisa que vocês fazem é tentar estabelecer common ground com o vosso interlocutor, vamos tentar criar aqui um substrato onde encontramos um vocabulário que nos permite estar em um comum denominador para arrancar a explicação, e isto é relativamente fácil porque nós vamos dizer, ok, tu dizes que tu entendes o funcionamento do DFS e o BFS, ok, então tu sabes que o algoritmo de busca não informada tem uma fase de inicialização na qual nós temos o grafo representado com uma lista de essências, temos uma variável que corresponde ao nó inicial a partir do qual tu começas a fazer a busca, tens um nó que é o teu nó objetivo, e tens uma estrutura que é a Q, que é a estrutura que vai ser manipulada na fase iterativa do algoritmo, e então, aí, nesse momento, vocês estabelecem um raporto com o interlocutor, temos um common ground, temos um ponto de partida, e a pessoa diz sim, eu entendo que existe uma fase de inicialização com três componentes essenciais, grafo, nó inicial, nó objetivo, mais inicialização de uma variável que será a que vamos utilizar e manipular durante a fase iterativa do algoritmo, ok, e então perguntamos ao interlocutor sabes como arranca e como termina a fase iterativa, e a pessoa responde sim, enquanto a Q tiver conteúdo, enquanto não tiver vazia, eu vou fazer uma série de passos, ah ok, e quais são os passos, ah, corto a cabeça do bicho, pego uma Q e parto a cabeça de um elemento e guardo o resto, pergunto se a cabeça é o goal state, se não é o goal state, eu sei que imediatamente vou perguntar, ok, cabeça, quem são seus filhos, para que na preparação da próxima iteração eu vou combinar o resto que trago de atrás com alguma coisa que vou fazer com os filhos, então já sabemos que DFS, filhos primeiro, resto depois, BFS, filhos primeiro, filhos depois, então aqui continuamos no percurso de estabelecer common ground com o nosso interlocutor, e fazemos isto porque o algoritmo de Dijkstra funciona com todo este esqueleto igual, temos a fase de inicialização, a fase iterativa é tudo exatamente igual, então o que eu vou dizer ao meu interlocutor é, ok, tu que entendes como funciona o DFS e o BFS, a diferença central do Dijkstra pode ser explicada em duas fases, primeiro, a definição do teu grafo muda, o grafo que nós usamos em busca não informada só representa as relações entre os nós, certo, nós agora vamos passar a representar custos ou distâncias como etiquetas dos links que estão representados no grafo, e então temos informação, quanto custa ou a que distância está a minha ligação entre um nó A e um nó B, ok, então essa primeira alteração é importante e essa alteração nos permite saltar de uma busca forçadamente não informada para uma busca que pode ser informada e portanto ser mais inteligente, porque uma coisa que eu tentei destacar a semana passada é que a busca não informada é discutivelmente inteligente e na verdade não é inteligente, a única coisa que a busca informada faz que é inteligente é sistematização geométrica da pesquisa do grafo de busca, porque não há nenhuma decisão quando eu tenho um conjunto de próximas ações que eu posso implementar que me vão levar a um nó ou a outro ou a outro, eu não tenho como decidir qual é a ação que vai maximizar qualquer utility que eu possa implementar, encontrar o caminho mais curto ou alguma coisa desse gênero, certo, então o que eu faço é sistematizar, e então eu digo ok, quando saltamos de busca não informada para busca informada a primeira coisa que muda, muda na fase de inicialização do algoritmo na qual tu agora vais ter um grafo anotado com os custos de distâncias de cada edge, e então aí vocês jogam a ser eu, professor, e perguntam ao interlocutor o que que tu farias com isto, e então possivelmente vocês estão à espera que as pessoas respondam, ah eu vou observar onde que eu estou neste momento em qualquer momento do ciclo iterativo, posso estar no ponto inicial ou posso estar em qualquer momento da execução iterativa do algoritmo e vou perguntar ok, já que estou aqui para onde que posso ir, posso ir para A, B ou C, qual é o que tem um link mais curto ou mais barato, e então vocês vão dizer, ah isso chama-se greedy search, e imediatamente vão colocar no quadro aquele exemplo que eu coloquei de que tu avanças por 1, 1, 1, te estás a afastar quando na verdade a outra opção que parecia no imediato um pouco mais cara no meio prazo é mais barata, certo, e então aí com isso vocês vão ancorar e dizer ok, uma vez que tu tens o grafo informado, dentro do algoritmo, quando tu fazias E primeiro e R depois, DFS, ou R primeiro, E depois, DFS, aí é que vamos alterar alguma coisita que vai ser um pouco diferente para implementar o algoritmo de Dijkstra, que é um algoritmo de busca informado, e então aí vocês dizem, olha, nessa altura até é mais fácil porque o que tu fazes é meter o resto, os que trazes de trás da queue, mais os novos, o E, metes tudo num saco e vais ordenar de menor a maior, e então o pessoal vai perguntar, mas de menor a maior que, que número que eu vou utilizar para anotar todos os paths abertos que eu tenho na queue, porque agora não se lembra que a nossa queue é sempre um path aberto com um nó terminal, certo, ou chegar a um nó por path, por caminho, seja qual for, e então aí vocês vão dizer ok, o número que tu vais usar para ordenar os caminhos abertos dentro da tua queue é todo o custo acumulado desde o nó inicial até o nó terminal do path que estás a avaliar, então em vez de ver só o que tenho em frente de mim, eu estou a usar a informação acumulada desde o início até o nó que estou a avaliar numa determinada iteração, então essa informação é anotada dentro de cada elemento da minha queue, sendo que neste momento a minha queue vai guardar três elementos, o nó terminal, o caminho que eu usei para chegar a esse nó terminal e o custo acumulado desde o ponto de partida, desde o nó inicial até esse nó terminal, certo, e então eu guardo isso em cada elemento da minha queue, meto tudo dentro de um saco e ordeno de menor a maior, e então o que fique com o custo acumulado menor vai ser a próxima cabeça da queue, e então nesse sentido, nós er ficam todos misturados, não é este bloco er que nós tínhamos na busca não informada, e então o percurso geométrico não é todo bonitinho como DFS ou BFS, tu vai sempre favorecer o caminho que com a informação que temos até agora parece ser o melhor, então não é griegue no sentido que o vosso interlocutor terá tendência a dizer aquela coisa de só olhar para o que está na ponta do teu nariz, não, eu não estou a olhar só o que está em frente da ponta do meu nariz, eu estou a guardar custo acumulado desde o inicio, então eu estou a usar uma informação um pouco mais abrangente do custo acumulado de tudo o que eu aprendi no percurso iterativo do algoritmo até agora, portanto não é um algoritmo reativo que só opera com base local de onde está neste momento, é um algoritmo que em cada interação vai atualizando a informação do que sabe dos diversos nós que fazem parte do grafo de busca, faz sentido? E então obviamente nesse momento vocês vão dizer uma coisa interessante sobre este algoritmo que nota que é muito fácil comparativamente ao algoritmo de busca não informada, é que existe uma demonstração matemática que garante que executando esse algoritmo sempre vai encontrar o caminho mais curto ou mais barato primeiro, certo? Outra coisa que vocês vão falar ou se já não falaram com o Zuil mais sobre esse assunto, quando até agora aqui na teoria, nós o que fazemos é, quando o algoritmo encontra um objetivo, exit, sai, acabou, ok, encontrei o primeiro caminho, faço um output, tchau, mas na verdade, e isso espero que faça sentido logicamente, eu posso dizer o algoritmo, porque se aqui não está terminada, se aqui eu contei elementos ainda, eu posso dizer o algoritmo continua, dá-me esse output, obrigado, tá lindo, ok, continua, isso em AI chama-se backtracking, backtracking significa volta para trás e continua para encontrar o próximo caminho, e então quando nós fazemos isso em Dijkstra, o algoritmo vai continuar a processar a Q e encontrará o próximo caminho mais curto, que será no melhor dos casos, igual de curto ao output primeiro que foi guardado e normalmente um pouco pior, incrementalmente, até termos consumido a Q completa, portanto logicamente pensem que eu posso adaptar o meu algoritmo de busca para dizer em vez de dar-me o primeiro output que consegues e terminar, continua a executar até que a Q fique vazia e vai fazendo os outputs até terminar, isto é equivalente a dizer, dá-me uma solução a primeira ou dá-me todas as soluções uma por uma, e isto podemos fazer tanto em Dijkstra como em DFS e sempre o igual, ok? Comentários? André? Acho que não, é mais agora construir, ou seja, a narrativa mais direta. O que me preocupa nessa parte, quando eu faço esta pergunta sobre como explicaria isto a uma pessoa com nível de educação médio, que mais ou menos vai entender os conceitos matemáticos, algoritmicos, eu noto que vocês se atropelam, tentam, mas se atropelam, ou ficam calados, que é o pior, ou depois tentam fazê-lo, mas se atropelam assim próprios, e então aí o que eu digo que aplica neste caso e aplica a qualquer outro caso quando estamos a tentar explicar uma técnica, um algoritmo ou uma equação matemática a outra pessoa que é relativamente inteligente, nós temos que primeiro tentar estabelecer common ground, um ponto de partida onde as duas pessoas se encontram, e tipicamente isso é vocabulário ou definições, imagina que tens uma variável chamada X, imagina que tens uma coisa não sei o que e que faz isto, então no âmbito da pergunta que eu estava a fazer e explica com uma narrativa coerente a um colega, talvez do ano anterior, que entendeu DFS e BFS como explica as Dijkstra, e então a minha estratégia é dizer ok, lembra-te que o algoritmo de busca que tu conheces tem uma fase de inicialização e uma fase iterativa, onde na fase de inicialização temos o grafo, o nó inicial, o nó objetivo, mais a variável Q que é a que vai ser operada na fase iterativa e a pessoa diz ok, e eu digo olha, quando passamos a busca informada, a primeira alteração acontece na fase de inicialização, temos um grafo que anteriormente era ligações entre nós sem informação agora temos um número associado a cada link, e esse número tem a ver com custo-distância e a pessoa vai dizer ok, make sense, pode ser quilômetros, pode ser euros, sei o que for, muito bem e então pergunta a uma pessoa, ok, uma vez que tu tens um grafo informado, o que é que tu farias com isto sendo que a expectativa que vocês vão ter é que a pessoa vai diretamente para o grid e search estou no nó, observo que são os filhos desse nó, e vou para o mais barato ou mais curto e vocês dizem ok, mas não, porque pode acontecer isto, de que o que parece melhor agora dois movimentos à frente é mau, e vocês dizem ok, para resolver o problema criado por grid e search o que Dijkstra faz é considerar qual é o caminho cujo custo-distância acumulada desde a origem, o único insight de Dijkstra é não consideres o que está em frente do teu nariz considera o acumulado desde o inicio, não há mais nada ai, nada mais e então eu vou ordenar a minha cube de acordo com o custo acumulado desde o inicio e com isto eu tenho garantia de que o primeiro caminho encontrado é o mais curto qual é a limitação de Dijkstra no mundo real, porque no mundo teórico é muito bonito tudo corres tudo no quadro e tudo faz sentido e está tudo ok mas no mundo real onde temos grafos muito grandes qual é o problema? se o valor da previsão for superior ao valor exato de que estás a falar? do custo do caminho entre os dois nós me parece que estás a falar das heurísticas sobre as quais não estamos a falar ainda estamos a falar de Dijkstra e não de Einstein portanto o tema das heurísticas ainda não entrou na equação ok já vamos passar por ai qual é o problema? Dijkstra não estima nada então quando eu coloco números nos links do grafo de busca que podem ser custos ou distâncias esses custos ou distâncias entre um nó A e um nó B são custos reais, são distâncias reais não são estimativas portanto toda esta coisa de estimar por cima é um assunto que não preocupa a Dijkstra porque Dijkstra não usa nenhum tipo de estimativa Dijkstra usa real information, não estimativas
Portanto, cuidado! Qual é o problema da distra? Professor, eu não sei se estão a ouvir. Sim, sim, sim, Fábio. Estava a pensar, ele tem que calcular esse acumulado por todos os possíveis ramos, não é? Exatamente isso, e nós mencionamos isso semana passada. Basicamente, o que acontece é que em grafos do mundo real, há uma coisa que nós temos que saber dos grafos e das árvores que tem uma propriedade, que é o branching factor, que é quantas ramas, a partir de um nó, quantos fios é que tu tens em média, isso chama-se branching factor, e não sei se já ouviram falar disso em alguma outra cadeira, e depois tens a profundidade da árvore. Então, quanto maiores essas duas variáveis, mais arbitrariamente complexo é o nosso grafo. E os grafos do mundo real, como devem calcular, tem branching factors elevados e profundidades, depth, também elevados. Pensem por um momento, por exemplo, num grafo do jogo de xadrez. Imaginem, em cada momento, todas as opções que um jogador tem e quantos passos em um grafo absolutamente gigante. E então, para que um agente inteligente possa, em tempo relativamente útil, dar resposta, o Dijkstra pode ficar aí, rucu, rucu, rucu, rucu, rucu, e está a fazer um bom trabalho, mas talvez tenha que avaliar muitas coisas antes de chegar ao caminho mais curto. E então, o problema que se coloca para Dijkstra é como é que nós podemos recortar, reduzir o número de computações necessárias para chegar ao caminho mais curto ou mais barato sem comprometer o que a demonstração matemática de Dijkstra garante, que é garantir que o caminho mais curto é o primeiro encontrado. E então, é aí onde nos saltamos de Dijkstra para ASTAR. Quando continuamos nesta conversa com o nosso interlocutor virtual ou real, num café, você vai dizer, ok, o problema com Dijkstra é super elegante, é como se fosse uma máquina de turing, de data busca, tudo que tem Dijkstra é necessário e minimamente suficiente, é uma coisa totalmente elegante, tem exatamente o que precisa, nada sobra, nada falta, Dijkstra é belíssimo, mas temos um problema que no mundo real pode demorar muito tempo e não ser pragmaticamente útil, e é aí onde a adição de um pequeno add-on nos permite ir de Dijkstra para ASTAR, e o add-on é a inclusão da heurística. E então aqui, se entramos na pergunta que o Miguel estava dizendo, no comentário que o Miguel estava fazendo, o que é a heurística? A heurística é uma estimativa, a heurística é uma estimativa que nos engenheiros informáticos não é o nosso problema, basicamente, não sabemos o que é a heurística, a heurística é uma estimativa de quanto falta para chegar ao destino, a um objetivo, e portanto eu tenho que definir essa heurística como uma função de cada um dos nós de busca em relação a um objetivo, e essa relação pode ser definida teoricamente, eu posso entender a teoria que gera o meu grafo de busca, pode ser teoria de jogos, pode ser teoria de relações espaciais para distâncias, pode ser teoria financeira se são custos, e essa teoria pode gerar uma fórmula que te permite calcular uma estimativa de quanto falta. Se tu soubesse quanto falta exatamente, isso seria equivalente a ter um turbante com uma matista e adivinhar o futuro, e ter o futuro já todo pré-calculado. Se tu tens o futuro pré-calculado, tu não precisas de fazer search, certo? Tu faz um catálogo e identificas qual é o caminho mais curto porque já está pré-computado. Tenho noção que temos pragmáticos e filosóficos, o problema de busca é que eu não sei o futuro a partir de um ponto onde eu estou. Então, como não sei o futuro, eu tenho que inteligentemente ir navegando o grafo de busca à procura do futuro que eu quero encontrar, que é por exemplo o caminho mais curto. Então, a adição de heurística significa que, ainda que eu não sei exatamente qual é o futuro, eu tenho uma estimativa. Então, essa ideia de estimativa é fácil de entender quando nós pensamos em relações espaciais, onde tu queres ir de Lisboa a Porto. E nós sabemos que na realidade não existe uma autoestrada em perfeitamente linha recta entre Lisboa e Porto. Há curvas, há desvios, blá, blá, blá. Mas eu posso fazer uma estimativa e dizer, no mínimo dos mínimos, linha recta. Então, eu uso essa linha recta como estimativa, ok? Então, nós a semana passada falamos de que a heurística é uma estimativa educada, informada. Pode ser informada por teoria ou pode ser informada por data. E posso recolher muitos dados, fazer médias, desvios padrões, estimativas, dizer o que há em média. Este é o valor esperado da coisa. Portanto, isto é importante, que a heurística pode ser informada por teoria ou por dados. É importante que saibam que a responsabilidade de identificar a heurística rara vez recai no engenheiro informático. Normalmente recai no domain expert, que é a pessoa que sabe como funciona o domínio que gera o grafo de busca. Xadrez, Google Maps, financeiro, seja o que for. O que eu tenho que garantir como engenheiro informático é que a heurística que me é dada, seja ela teórica ou data driven, tenho que ter algum tipo de garantia estatística ou matemática, alguma coisa que me faça confiar que essa heurística não estima por cima do valor real, sempre por baixo. Por quê? Porque se a heurística estima por cima do valor real, se sobreestima, a garantia que eu tenho de Dijkstra desaparece. Mas, por outro lado, se eu aceito heurísticas que estimam muito por baixo do valor real, então estou cada vez mais próximo de Dijkstra. Então aqui é uma espécie de trade-off. Eu quero encontrar a heurística que não sobreestime, e isso é o que nós chamamos de admissibilidade, a semana passada. Eu quero encontrar a heurística admissível, a melhor que me garanta que não sobreestima, mas que estima mais próximo do custo real. Portanto, é a dominante. Quanto mais dominante, quanto mais próxima do valor real, ou quanto maior garantia, nós temos de que não há sobreestimação e a heurística é maior que outras disponíveis. Então eu vou optar por essa heurística. Eu vou preferir heurísticas sempre admissíveis, e dentro das admissíveis a mais dominante é a que estima os valores de média maiores. Porque essa é a que vai conseguir fazer uma maior redução do número de iterações necessárias. No Dijkstra, agora é estar para convergir ao caminho mais curto ou mais barato. Sim? Então, o que acontece em termos algorítmicos é que você vai ao seu interlocutor dizer que em Dijkstra você está ordenando a Q de acordo com os valores de custo acumulado desde o início. Quando você passa a estar, o valor que você vai usar para ordenar a Q, de menor a maior, é o custo acumulado desde o início mais heurístico. A partir desse não quanto, estimamos que falta. E esse é o valor que você vai usar. Portanto, em termos estruturais, o algoritmo é exatamente igual. A única coisa que muda é o valor que estamos usando para ordenar a Q. Em Dijkstra, custo acumulado desde o nó inicial. Em EISTAR, custo acumulado desde o nó inicial mais a heurística desde onde está, desde a cabeça de onde está agora, até o final. Sim? Sim ou não? É importante que os que felizmente estão aqui na sessão me digam se entendem ou não entendem, porque obviamente isso vai ser material avaliado no juízo daqui a duas semanas. Só para ter aqui uma pequena garantia de que vocês estão entendendo o que está acontecendo, eu vou compartilhar aqui os slides da semana passada. Este último slide. Então, é preciso que vocês procurem papel e lápis, porque quero que façam duas ou três iterações, mas para já vamos tentar perceber qual é o problema que se coloca aqui. Desculpem. O problema é que eu não sei o que está acontecendo aqui. Vamos tentar perceber qual é o problema que se coloca aqui. Ok, então primeiro este tipo de grafo é diferente aos grafos que nós temos visto até agora em busca em EI. Quando vemos esta grelha, imediatamente pensamos, uuuh, o que está acontecendo aqui? Não se está passando nada surreal. Basicamente isso significa que nós temos 36 nós no nosso espaço de busca, ok? Um nó é chamado A1, outro é B1, outro é A2, portanto nós podemos escrever uma função geradora, e notem que isso existe em um domínio específico, que será uma aplicação de videojogo, onde temos um agente que está num mundo grelha. Muitos videojogos que nós conhecemos são este tipo de mundo grelha, ok? E o mundo grelha tem uma dimensão de posições que você pode ocupar. Então essa dimensão tem um valor no X e um valor no Y. Então se no meu caso é 6 e 6, eu posso escrever uma função de código que diga, ok, considerando a coordenada X representada com as letras A, B, C, etc, e a coordenada Y representada com os números 1, 2, 3, etc, gera um mundo grelha, uma lista de adjacências de 6 por 6, 36 nós. Então vocês podem, com um bocadinho de trabalho, não agora, obviamente, mas com certeza, com esta especificação, vocês conseguem escrever uma função de Python que recebe a dimensão no X, a dimensão no Y, os símbolos utilizados para representar a coordenada X, os símbolos representados para a coordenada Y, os obstáculos, que posições não são, que se podem aceder, e gerar uma lista de adjacências em Python, em JSON, um dicionário que representa corretamente isto. Isto é um trabalho que vocês farão na prática. Não agora. Neste caso, no nosso caso, já está definido o grafo graficamente aqui. O que é importante saber é que cada quadradinho destes corresponde a um nó. E que deste nó que está aqui, que é o A1, e tal como indicam as instruções que estão aqui, diz, ok, de A1 eu posso ir para A2 ou para B1. Portanto, cada nó eu posso ir para o norte, para o sul, para o oeste ou para o oeste. E quando estou em boundaries, na fronteira, obviamente, não é acessível o oeste. E quando há um obstáculo, também é como se fosse um boundary. Isto não é, não pode aceder a este nó que está aqui. Ok. Dado este grafo de busca, a outra coisa que nós temos que saber é que os movimentos são todos iguais para o robot. Norte, sul, leste, oeste, vão ter um custo associado igual a 1. Portanto, quando eu inicializo o grafo de busca, 1, 1, 1, 1, 1. É uma grelha regular. Se fosse uma grelha irregular, os custos poderiam variar entre nós, mas neste caso, para simplificar, é todo 1. Ok. Portanto, temos o nosso grafo de busca com as anotações dos custos. Portanto, eu já posso executar Dijkstra. Não preciso de nada mais, certo? Tenho o grafo de busca com as anotações de qual é o valor, neste caso, distância, ou custo, associado a cada movimento do robot. Neste momento, eu posso correr Dijkstra para ir deste nó, para este nó. Portanto, façam duas iterações de Dijkstra. No papel. Dois, três minutos e me comentem. Eu quero ouvir o que vocês estão a fazer. Vou retirar o... Não sei se eu devia pausar a gravação. Vamos deixar assim. Quem estiver a fazer isto, quando estiver a ver o vídeo, aproveite este tempo para fazer o que os colegas estão a fazer agora, que é pensar nas iterações, fazer duas iterações, não de Estar, mas sim de Dijkstra. SE INSCREVA NO CANAL INSCREVA SE NO CANAL COMPARTILHE FALE ALGUMA COISA Alguma coisa que imediatamente lhe chame a atenção na execução do primeiro passo do DIGSTRA nessa situação? COMO CONTINUAR A CONVERSA COM A SUA COLEGA? Imaginem que continuamos a conversa com o nosso colega no café e estamos tentando aqui passar algum insight, alguma coisa que nós estamos a observar no âmbito desse trabalho de entender esses algoritmos de busca alguma coisa que chame a atenção e aqui não sei se estão presentes o André, o Wisley e o Miguel acho que há mais pessoas, e o Fábio que também falou acho que há mais pessoas aqui na sala COMO CONTINUAR A CONVERSA COM A SUA COLEGA? Quando eu faço a primeira iteração do DIGSTRA imediatamente me salta ao meu espaço cognitivo um dos elementos que discutimos a pouco tempo quando começamos a falar do EISTAR e antes do DIGSTRA também COMO CONTINUAR A CONVERSA COM A SUA COLEGA? Conseguem identificar? O que é o EISTAR? O que é o EISTAR? O que é o EISTAR? O que é o EISTAR? O que é o EISTAR? O que é o EISTAR? O que é o EISTAR? O que é o EISTAR? Wisley, está a falar conosco? Sim, estava aqui a pensar na resposta Como vai ver a resposta? Quando eu faço a primeira iteração do DIGSTRA que característica da primeira iteração salta à vista imediatamente? Que característica tem a execução do DIGSTRA que salta imediatamente à vista? Diga lá. O que acontece na primeira iteração? Diga lá. O que acontece na primeira iteração? Diga lá. O que acontece na primeira iteração? Diga lá. O que acontece na primeira iteração? Luisa, estás aí? Luisa, estás aí? Na primeira iteração... Quem está a falar? O Fábio. Eu não sei se estão a ouvir Eles só podem me ouvir em estrelas
E, portanto, a heurística em si é um passo, para cada lado, é que vai calcular o mesmo para todas as distâncias, não sei se era por aí. Espera, espera, espera, Fábio, aqui não há heurística, estamos em Dijkstra, cuidado. Certo, não diga heurística, mas em si o valor que ele vai calcular é um para todas, se calhar era mais isso que eu queria dizer, a heurística seria a sua supervisão, não é? Sim, cuidado. Muito cuidado com as palavras que usam depois das respostas nos quizzes. Então, o tipo de narrativa que nós usamos quando estamos a executar um algoritmo de busca, nós dizemos, eu estou no nó B2, e então esse nó B2 é a cabeça da minha Q, corto, e tenho a cabeça B2, é B3, não, sempre começamos assim, certo? Perguntamos cabeça, perguntamos se cabeça é o gold state, certo ou falso? B2 é E3, não, ok, quem são os seus filhos, ah, os meus filhos são, eu posso ir de B2 para B1 com custo 1, eu posso ir de B2 para A2 com custo 1, eu posso ir de B2 a B3 com custo 1, eu posso ir de B2 a C2 com custo 1, certo ou falso? Certo. O que me salta imediatamente, o que salta à vista, o que salta à vista é que, neste momento, com a informação, so far, acumulada, todos os caminhos são iguais, todos os caminhos são iguais, não tenho, neste momento, com a informação acumulada do Dijkstra, não tenho forma de discriminar nada, nada, nada, e então se vocês continuam a correr o Dijkstra e fazem 1, 2, 3, 4, vocês vão notar ou deveriam notar que, iterativamente, o algoritmo está, de alguma forma, a aprender, porque os custos acumulados começam a ser cada vez mais informativos de por onde é que chega a flor e por onde é que não chega a flor, concordam? Sim. Ok, isso é importante, agora, quando eu introduzo a heurística do Manhattan Distance, o que acontece? Na primeira iteração eu vou dizer, ok, posso ir de B2 a B1, portanto, de B2 a B1 com custo 1, que é o custo so far acumulado, mais a heurística, que é a distância de Manhattan, portanto, desde este ponto eu vou contar 1, 2, e não sei se é um obstáculo, 3, 4, 5, portanto, 1 mais 5, 6, aqui, se eu for para aqui, de B2 para C2, será 1 mais 1, 2, 3, 4, de aqui, 1 mais 1, 2, 3, 3, de aqui, 1 mais 1, 2, 3, 4, 5, 6, por onde é que ele vai ir? Por aqui. Então, notem que só a inclusão da heurística, comparativamente a o Dijkstra, na primeira iteração, já é totalmente diferente. Então, isto, quando nós estamos com o nosso colega no café e metemos o papel com o lápis e mostramos, o colega vai pensar, you are very clever, isso é bom para dates e coisas assim. Por exemplo, sem a heurística ele iria expandindo, ou seja, por exemplo, fazíamos os primeiros para onde ele pode ir, neste caso o B1, o A2, o C2, e pronto, e depois para cada um desses também íamos ver, íamos fazendo assim até chegar à dica do lado. O que é que tu notas no Dijkstra? No Dijkstra, se tu fazes fast forward e vês a execução, tu vais ver que ele começa tipo a expander para todo lado, mas a partir de certo momento, quando acumulaste certa informação, os melhores caminhos já começam a ganhar cada vez mais e vão ficando os outros para trás. Mas demora a toda uma fase inicial, onde todos os caminhos são mais ou menos iguais, porque estás só a acumular pequenos passos, avancei para aqui, avancei para aqui, então é um a um. Mas a partir do momento que, nessa construção que ele faz, deteta algum tipo de alteração de custos, ele vai sempre para os menores. O algoritmo do Dijkstra não detecta nada. Mas ele vai acumulando custos. Claro, então o mecanismo que faz com que o Dijkstra consiga fazer a convergência o mais curto, é porque na acumulação, basicamente ele está a explorar todo o espaço e está a usar no conhecimento do cost so far, quem é o mais curto. Quanto mais te vais aproximando do objetivo, a competição fica mais fechada e o caminho que é mais curto, começa a ganhar mais na cabeça. Mas tem que acumular bastante. Por exemplo, se tu não tiver esses obstáculos e nada disso, o algoritmo teria que acumular muita informação de tudo o que acontece aqui à volta, antes de que isso comece a ganhar por aqui. Então, para entender isso, o que eu recomendo é que há muitos vídeos em Youtube que mostram a execução de Dijkstra e ASTAR. Mas o que eu queria mostrar aqui, que para mim é super importante, em termos conceituais, vejam que na execução da primeira iteração do Dijkstra, comparativamente à execução da primeira iteração do ASTAR, o panorama do mesmo problema é radicalmente diferente. Sendo que no Dijkstra, é tudo muito simétrico, é tudo muito igual, certo? E no ASTAR, só com a informação da heurística, já há muita mais assimetria, e assimetria que favorece efetivamente o caminho que acabará por ser o mais curto. Vejam aqui, o que temos falado das heurísticas, 4, 4, 6, 6, vai por aqui ou por aqui, vai por aí, mas encontra obstáculos, expande, compara, agora o próximo melhor será este, e por aí fora, começa a acumular informação até chegar ao mais curto. Muito importante. Ok, pessoal, esta recapitulação demorou mais tempo do que eu tinha contemplado, vamos falar rapidamente, ou pelo menos introduzir bem o problema de minimax, e eu vou partilhar um notebook, um desses cadernos que eu tenho partilhado convosco no passado, é absolutamente crítico, que estudem esse notebook para a próxima sessão, porque na próxima sessão vamos passar rapidamente por uma coisa que chamamos de alfa beta pruning, esclarecer isso bem, e avançar um pouquinho para NLP, vou fazer um stop share aqui, passar agora slides para os outros, partilhar, então, eu tenha feito uns teasers do que seria eventualmente a busca adversarial, o que vocês entendem que pode ser a busca adversarial, nós temos aqui a noção de busca não informada, sistematização geométrica, depth first, breadth first, blá blá blá, temos agora uma noção muito mais clara de busca informada, custo acumulado dixtra, custo acumulado mais jurística é estar, muito bem, e assumindo que esta medida de custo ou distância, pode ser vista como um utility, estou sempre a procura do caminho mais curto, então, temos o agente racional de busca, juntamente com um grafo de busca, onde o objetivo é que o agente racional faz uma análise offline do grafo de busca, encontra um caminho, faz um plano e implementa, o que poderia ser adversarial search diferente, o que poderia trazer de diferente? Se calhar, se calhar considerar mesmo os resultados, por exemplo, aqui, este caso, nós já sabemos que na primeira busca, temos caminhos que são mais longos que o outro, e podemos descartar se calhar logo outros caminhos, por já, se calhar, não fazerem sentido continuar a procurar. Vamos primeiro entrar pela palavra adversário, que significa oponente, certo? Pensando assim, como se fosse, por exemplo, o jogo de xadrez, em que eu tenho que maximizar as minhas chances de ganhar, nesse caso contra o adversário. Ok, e em termos do processo de decidir, a busca adversarial, se nós pensamos no significado da palavra adversário, significa que o nosso agente de busca tem um oponente, e isso deixa um pouco preocupado, porque se eu sou agente racional A, e tenho um oponente, o mais provável é que o meu oponente seja agente racional B, e então aí, eu já fico com a mosca atrás da orelha, porque significa, ok, aqui há dois agentes a fazer busca no mesmo search space, e cada um está a puxar a brasa para a sua sardinha. Agora, o que significa puxar a brasa para a sardinha de cada um dos agentes? Em termos pragmáticos, o que poderá significar? Notem que, quando temos uma busca que é um agente em busca informada, o grafo de busca é imutável, está sempre disponível, os filhos de A são sempre os filhos de A, os filhos de B são sempre os filhos de B, porque não há nada que esteja a alterar o grafo de busca enquanto o nosso agente está a trabalhar, certo? Portanto, todas as ações do espaço no grafo de busca estão, em princípio, disponíveis para o nosso agente, sempre, todas. Agora, na busca adversarial, o que acontece é que, cada vez que eu decido uma ação e implemento essa ação, o outro agente vai implementar outra ação que vai fechar os meus caminhos. E então, todos os filhos que, em uma situação uniagente, estariam, em princípio, todos disponíveis, o oponente vai vir e, porque vai fazer um move, vai implementar uma ação que vai deixar as minhas opções reduzidas. Isso é a essência de busca adversarial. Faz sentido? Muito importante. Quando eu tenho um agente único, o espaço de busca, o grafo de busca, com todas as ações, que são os links, que me permitem ir de um nó para outro, estão todos sempre disponíveis e eu posso percorrer todos os caminhos do grafo e eu posso precalcular tudo e está tudo disponível. Em busca adversarial, eu tenho dois agentes que estão a fazer uma busca um contra o outro, e um contra o outro significa que os números que estão dentro dos links se vão traduzir em utilidade ou desirability para um agente que é oposto ao desirability do outro. Se eu tenho um jogo da velha, obviamente o oponente vai tentar fazer um move, colocar a sua peça, x ou círculo, no sítio que faça mais difícil ao oponente chegar a ganhar o jogo. Certo? Então, isto em termos práticos, o que significa é que, como temos busca adversarial, o agente oponente, um agente, vai tentar maximizar a sua utilidade, certo? Enquanto que o oponente vai minimizar a utilidade do outro. Então a forma como nós dizemos, agente A maximiza a sua utilidade e agente B maximiza a sua utilidade, nós simplificamos isto, nós dizemos, ok, agente A maximiza a utilidade, vamos ter uma noção genérica universal de utilidade, ok, que pode ser quão próximo estou de ter os 3x ou os 3 círculos no jogo da velha, e então um agente maximiza essa utilidade, enquanto que o outro A minimiza a mesma utilidade. Porque senão teríamos que estar a trabalhar com números duplos dentro do grafo de busca. A utilidade A e a utilidade do B, mas como são dois oponentes, nós podemos simplesmente reduzir e dizer, ok, agente A maximiza a sua e agente B minimiza essa, e é totalmente consistente com o nosso objetivo, ok? Então aqui, usando o jogo da velha efetivamente como exemplo, quando estamos aqui no início todas as alternativas são possíveis para colocar o X, neste momento ainda não aconteceu nada, mas aqui este agente, este agente que está aqui, que vai maximizar a sua utility, vai tentar ver no futuro, vai tentar prever o futuro, qual destas ações é a que com mais probabilidade levará a este agente que maximiza a sua utilidade, vamos chamar de agente A, a ganhar o jogo, ok? Então intuitivamente nós tínhamos uma pergunta na busca informada que era, ok, se tu tens uma situação onde tens os custos ou distâncias associadas ao grafo de busca, o que é que tu fazes, e o nosso interlocutor virtual diz, ah, eu vou olhar para dado meu nó atual e olho para os nó filhos que eu posso atingir e vejo qual é o mais curto, nós sabemos que isso é Greedy Search, ok? Então nós corrigimos o Greedy Search com DISTRA, posteriormente com AISTAR, tudo bem. E se coloca uma pergunta análoga a essa situação que é a seguinte, o que que intuitivamente nós fazemos aqui? Ver quais problemas, problemas entre aspas, que apareceram a partir do momento que você tomou uma iniciativa e meio que se programar para combater esses problemas. E como representas esse problema no teu código? Ok, então nesse caso o que, uma das alternativas seria tentar como, digamos, vou tentar seguir a linha de pensamento da Luisa, nós iríamos simular muitos caminhos até o futuro final, o FATE, e identificar características dos caminhos que eu posso de alguma forma padronizar e quando vejo alguma configuração com certas características, não vou por aí, é isso que quer dizer? Sim, por exemplo, se eu meter o X logo assim, sei lá, por exemplo, no meio, eu sei que para eu ganhar eu posso colocar ele em todas as minhas diagonais, mas eu também posso colocar para cima, para baixo e para os dois lados, então acho que vai depender muito de literalmente cada passo que você tomar, até que vai chegar um momento que você só tem um caminho para ir, mas foi como o professor falou, no início você tem vários caminhos e aí você vai e toma uma iniciativa, e aí depois a pessoa vai e toma outra iniciativa para bloquear o seu caminho, e depois você vai ficando com cada vez menos opções para poder, nesse caso, ganhar. Então, uma coisa que nós poderíamos, em princípio, fazer é, dada a configuração da situação onde existe um agente e o seu oponente, nós começamos a expander os diferentes caminhos, ok? E vemos, por exemplo, com que probabilidade, quando eu coloquei o X aqui, nesta diagonal superior esquerda, com que probabilidade que eu ganhei? E ver, nas situações em que eu ganhei, se a probabilidade é 0.6, então eu digo que a utilidade associada a este movimento é 0.66, e então vou comparar a utilidade desse, e uso essa utilidade para decidir o meu próximo move. Qual é o problema que vocês acham que se pode colocar com isso? Então, retomando e recapitulando, a proposta da Luisa é uma espécie de, vamos correr, digamos, umas simulações de percursos possíveis futuros que podem acontecer, e aprender características que me permitam fazer uma espécie de if-this-then-that, regras, que são baseadas em características padronizáveis, que agrupam diferentes futuros em uma categoria que, se vais por este tipo de move, vais perder. Se vais por este tipo de move, 50-50. Se vais por este tipo de move, mais provável que vais ganhar. Isto faz sentido, logicamente, certo? Tipo, eu faço uma simulação, aprendo dos possíveis futuros.
categorizo, por aqui vai perder, por aqui 50-50, por aqui pode ganhar, mas é sempre probabilístico Qual é o problema com isso? Para explicar o problema com isso, eu vou parar este share e vou fazer o que eu avisei no inicio da sessão que poderia correr mal, vamos ver se corre relativamente ok Vou parar o share aqui e fazer outro share Estão a ver o meu ecrã? E se eu escrever uma coisa conseguem ver? Então o problema técnico não aconteceu Então, para entender qual é o problema da abordagem da Luisa, que não é uma abordagem burra nem muito menos É uma coisa que, de facto, em Data Science fazemos isso Há muitas situações nas quais nós simulamos futuros e aprendemos esses futuros, vemos features características e aprendemos padrões que são categorizáveis Um dos problemas conceituais disto é que, às vezes, o tipo de problema que nós estamos a tentar resolver não cria asimetrias suficientes para separar É como que tudo parece igual O agente fica wow, todos os futuros parecem iguais, tudo que eu faço parece igual, isso é problemático Mais próximo do tipo de algoritmo que nós temos visto até agora, que não é até agora nem vamos avançar para algoritmos que aprendem com dados, identificam features, fazem padrões Nós não estamos nesse tipo de arena, estamos numa arena muito mais de engenharia de software, com grafos Então, vamos supor que nós temos aqui um nó inicial, e que esse nó inicial pode ter 3 opções Imagine que este jogo te permite 3 opções Então, o filho tem 3 opções E este filho tem 3 opções E este filho tem 3 opções Como disse anteriormente, neste tipo de grafos que são árvores, existe uma coisa chamada branching factor Que é o número médio de filhos que cada nó tem Neste caso, o nosso branching factor é 3 Certo? E nós fizemos uma expansão a profundidade 2, 1 e 2 Portanto, d é igual a 2 Estes dois parâmetros em grafos são super importantes, porque nos permitem saber, por exemplo quantos terminais, quantos nós terminais que nós temos, rapidamente Neste caso, eu faço b elevado a d, que é 3 elevado a 2, 9 Agora, qual é o branching factor do jogo da abelha? Varia, porque no início é 9, depois é 8, depois é 7 Vou fazer aqui em média 5 Ok? E a profundidade que eu preciso saber para decidir estes padrões Imagina que seja um 7, 5 elevado a 7, que já é um número grande Só para o jogo da abelha Então, imagine isto para um gráfico do mundo real O problema principal que se coloca na abordagem apresentada por Luisa é este problema da dimensionalidade do gráfico de quanto é que nós temos que simular para aprender Então, nós podemos rapidamente, só com o branching factor e com a profundidade, dizer Ok, com este branching factor e se aprendemos a dez movimentos do jogo nós vamos ter que fazer N computações onde N é b elevado a d, que tipicamente vai ser um número muito elevado E então isto coloca limites computacionais bastante importantes Certo? Luisa? Sim, sim Então, a abordagem não é descabida, não é que não tenha a sua função De facto, existem algoritmos que fazem este tipo de coisa Mas o tipo de algoritmo que nós implementamos em busca adversarial não faz isto Faz outra coisa Então, o algoritmo que nós implementamos para busca adversarial faz Eu tenho aqui, já tinha prefabricado este exemplo pelo downgrade da beleza dos slides comparativamente à semana passada Mas basicamente isto representa um pouco o que nós queremos pensar na busca adversarial Aqui temos um grafo de busca onde temos aqui o nosso agente inicial que quer maximizar a sua utilidade e que tem disponíveis duas ações que vamos chamar ação A e ação B E nós sabemos que depois desta ação o agente que vai minimizar é o que joga Ok? E este agente vai ter duas alternativas depois vai ser o oponente outra vez depois o oponente, o vermelho outra vez que vai minimizar e depois aqui o que nós fazemos é para uma determinada profundidade que determina um nível de aprendizagem que nós obtemos para este tipo de algoritmo de busca adversarial de 2, 3, 4 quanto mais profundidade mais computação é necessária voltamos o problema retirado da abordagem proposta por Luisa Aqui temos uma profundidade de 1, 2, 3 e 4 D igual a 4 E aqui neste momento o que nós fazemos é calcular a utilidade de cada um dos caminhos e a utilidade em relação a o maximizador então se isto acontece este agente toma esta ação o oponente toma esta o inicial toma esta e o oponente toma esta a utilidade para o verde é 8 e utilidade pode ser qualquer coisa quão próximo estou de ganhar é uma medida de quão bom é este caminho pense que quão próximo estou de ganhar o jogo do vermelho então quando nós precalculamos isto nós temos o maximizador o minimizador os moves do jogo para cada um e expandemos o grafo em determinada profundidade neste caso 4 e calculamos a utilidade para o inicial o nosso agente maximizador e temos essas utilidades calculadas no fim com isso, com essa inicialização nós podemos fazer o algoritmo iterativo chamado minimax minimax o que acontece aqui, no minimax eu vou fazer uma espécie de BFS ao contrário de baixo para cima eu vou começar por aqui entre 8 e 7 o que o minimizador vai escolher 7 7 peço desculpa interromper, só uma questão eu não percebo qual é a conta que faz para chegar à utilidade neste caso o 8 ou o 7 não interessa tu podes definir a utilidade por exemplo qual é a distância entre o board como está configurado neste momento e um board ganhador e calculas uma distância e no próximo estás de ganhar a utilidade pode ser definida de muitas formas e tal como falamos na heurística vamos assumir que a utilidade é um given nos é dado esse valor pode ser dado como uma fórmula ou pode ser dado como um número não interessa, a utilidade para nós é simplesmente um número que nós usamos para executar o algoritmo e o preciso que vocês entendam de utilidade é que tão boa essa situação para neste caso este agente então este caminho que vai por aqui, por aqui, por aqui tem utilidade 8 que é melhor que esta utilidade deste caminho que é 3 isso é o preciso que entendas sim? agora que caracteriza intrinsecamente a utilidade se é uma distância se é uma probabilidade pode ser qualquer coisa eu preciso de um número chamado utilidade que este agente vai maximizar e que está associado a benefício como ganhar um jogo ou estar mais próximo de chegar ao destino no google maps qualquer coisa dessas utility te dá um sentido de que tão bem estou no que estou a fazer ok? sim ok correto? pessoal? sim ok e aqui que vai fazer o minimizador? 3 entre 3 e 9 3 quando eu subo para cima o maximizador que vai fazer? 10 quem disse 10? eu disse 3 esqueço o 7 e o 3 então quando nós temos aqui a utilidade final nós temos um minimizador o minimizador sempre vai ir pelo mais pequeno portanto o minimizador vai optar por 7 aqui nesta situação o minimizador entre 3 e 9 vai optar por 3 quando toca agora o maximizador entre um caminho que lhe dá utilidade 7 e um caminho que lhe dá utilidade 3 para onde ele vai? para maximizar 7 ok? e vocês começam a ver que o algoritmo é extremamente fácil o minimax é basicamente ir propagando isto para cima então aqui entre 3 e 9 o minimizador faz o que? 3 entre 2 e 4 o minimizador faz o que? 2 entre 3 e 2 o maximizador faz o que? 3 entre 3 e 7 o minimizador faz o que? 3 e vão propagando isto de baixo para cima professor neste caso peço desculpa novamente neste caso o professor definiu como os vermelhos o minimax e os vermelhos os maximizadores então sempre isto é por definição nós sempre temos quando estamos a tomar uma decisão na execução iterativa do algoritmo minimax esta é a cabeça esta é a cabeça do da tua cue ok? então neste momento a cabeça da tua cue é um maximizador digamos que entre o agente A o teu agente é tu e o agente B é o teu oponente ok? então quando a cabeça é o maximizador então nós vamos procurar maximizar isto quando a cabeça é o minimizador nós vamos minimizar isto então basicamente o problema que se coloca para o teu agente maximizador neste momento que é o que está na cabeça ok? isto é a cabeça ele pergunta vou por aqui ou vou por aqui? e o que vai decidir se vai por aqui ou vai por aqui é qual destes caminhos vai dar uma utilidade maior maior se em outra situação a minha cabeça não é este mas é este que está aqui vou fazer toda a propagação destes valores por aqui e vou calcular o valor para este e qual vai ser a opção do minimizador o mais pequeno não o maior aqui ele vai ir pelo maior este vai ir sempre pelo menor e assim iterativamente um agente maximiza o outro minimiza mas aqui o que eu quero explicar é quando temos a situação temos a cabeça, temos o agente maximizador temos que escolher entre este caminho e este caminho qual será a opção do agente por este lado se nós vamos por este caminho sabemos que o nosso agente, o máximo que vai conseguir é 3 porque assume que o minimizador sempre vai fazer a sua melhor jogada e minimizar o máximo deste lado o que acontece? deste lado o que acontece entre 1 e 8? 1 entre 8 e 9 8, 9, 9 9, 3 e 4 3 aqui entre o maximizador entre 1 e 8 o que faz? entre 9 e 3 o minimizador entre 8 e 9 qual é a decisão que o nosso amigo verde vai tomar aqui? por onde vai? por este lado eu posso fazer exatamente a mesma coisa para este amigo que está aqui mas quando eu calcule estes números para onde ele vai? por aqui entre 8 e 9 o minimizador vai por aqui vai para 8 certo? pessoal? ok? ok       ok ok ok
